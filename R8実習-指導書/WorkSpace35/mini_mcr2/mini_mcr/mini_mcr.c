//------------------------------------------------------------------------------
// 対象マイコン R8C/35A
// ﾌｧｲﾙ内容     走行プログラム
// バージョン   Ver.1.00
// Date         2009.07.01
// Copyright    ルネサスマイコンカーラリー事務局
//              日立インターメディックス株式会社
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// インクルード
//------------------------------------------------------------------------------
#include "sfr_r835a.h"

//------------------------------------------------------------------------------
// シンボル定義
//------------------------------------------------------------------------------
#define TIMER_CYCLE     155             // 1ms:0.001/(1/(20000000/128))-1
#define PWM_CYCLE       39999           // 16ms:0.016/(1/(20000000/8))-1

#define Def_500Hz       4999            // 500Hz:(1/500)/(1/(20000000/8))-1
#define Def_1000Hz      2499            // 1000Hz:(1/1000)/(1/(20000000/8))-1

#define Def_C3          19083           // ド:(1/131)/(1/(20000000/8))-1
#define Def_D3          17006           // レ:(1/147)/(1/(20000000/8))-1
#define Def_E3          15151           // ミ:(1/165)/(1/(20000000/8))-1
#define Def_F3          14285           // ファ:(1/175)/(1/(20000000/8))-1
#define Def_G3          12754           // ソ:(1/196)/(1/(20000000/8))-1
#define Def_A3          11362           // ラ:(1/220)/(1/(20000000/8))-1
#define Def_B3          10120           // シ:(1/247)/(1/(20000000/8))-1
#define Def_C4          9541            // ド:(1/262)/(1/(20000000/8))-1

#define DI()            asm("FCLR I")   // 割り込み禁止
#define EI()            asm("FSET I")   // 割り込み許可

//------------------------------------------------------------------------------
// 関数プロトタイプの宣言
//------------------------------------------------------------------------------
void init( void );
unsigned char sensor( void );
void motor( int data1, int data2 );
void timer( unsigned long timer_set );
void beep( int data1 );
unsigned char dipsw( void );
unsigned char pushsw( void );

//------------------------------------------------------------------------------
// グローバル変数の宣言
//------------------------------------------------------------------------------
unsigned long   cnt0 = 0;               // timer関数用
unsigned long   cnt1 = 0;               // main内で使用
int             pattern = 0;            // パターン番号

//------------------------------------------------------------------------------
// メインプログラム
//------------------------------------------------------------------------------
void main(void)
{
        // 初期化
        init();

        // 起動音
        beep(Def_500Hz);
        timer(100);
        beep(Def_1000Hz);
        timer(100);
        beep(0);

	while(1){
		switch( pattern ){

        //----------------------------------------------------------------------
        // パターンについて
        //  0 : スイッチ入力待ち
        //  1 : 1秒後にスタート
        // 11 : 通常トレース
        // 21 : クロスライン検出後のトレース、クランク検出
        // 22 : クランクの曲げ動作継続処理
        // 31 : 左ハーフライン検出後のトレース、左レーンチェンジ検出
        // 32 : 左レーンチェンジ曲げ動作継続処理
        // 33 : 左レーンチェンジ終了検出
        // 41 : 右ハーフライン検出後のトレース、右レーンチェンジ検出
        // 42 : 右レーンチェンジ曲げ動作継続処理
        // 43 : 右レーンチェンジ終了検出
        //----------------------------------------------------------------------

        case 0:
                // スイッチ入力待ち
                if( pushsw() == 1 ){
                        beep(Def_1000Hz);
                        cnt1 = 0;
                        pattern = 1;
                }

                break;

        case 1:
                // 1秒後にスタート
                if( cnt1 >= 1000 ){
                        beep(0);
                        cnt1 = 0;
                        pattern = 11;
                }

                break;

        case 11:
                // 通常トレース
                beep(0);
                
                switch( ( sensor() & 0x0f ) ){ 
                
                case 0x06:
                        // 0000 0110 センタ→まっすぐ
                        motor( 100, 100 );
                        break;

                case 0x04:
                        // 0000 0100 少し右寄り→左へ小曲げ
                        motor( 85, 100 );
                        break;

                case 0x08:
                        // 0000 1000 大きく右寄り→左へ大曲げ
                        motor( 55, 100 );
                        break;

                case 0x02:
                        // 0000 0010 少し左寄り→右へ小曲げ
                        motor( 100, 85 );
                        break;

                case 0x01:
                        // 0000 0001 大きく左寄り→右へ大曲げ
                        motor( 100, 55 );
                        break;

                case 0x0f:
                        // 0000 1111 クロスライン検出
                        break;
                default:
                        break;
				} //　end of pattern 11
			break;

		}// end of switch
				
	}//  end of main-Loop
		
}// end of main

//------------------------------------------------------------------------------
// R8C/35Aの内蔵周辺機能の初期化
//------------------------------------------------------------------------------
void init( void )
{
        unsigned char i = 0;

        // 割り込み禁止
        DI();

        // クロック発生回路のXINクロック設定
        prc0 = 1;

        cm13 = 1;
        cm05 = 0;
        while(i <= 50) i++;
        ocd2 = 0;

        prc0 = 0;

        // I/Oポートの入出力設定
        prc2 = 1;                       // pd0レジスタへの書き込み許可
        pd0 = 0xe0;                     // P0_0〜P0_3:センサー
                                        // P0_4:マイクロスイッチ
                                        // P0_5〜P0_7:LED
        prc2 = 0;                       // pd0レジスタへの書き込み禁止
        pd1 = 0xdf;                     // P1_0〜P1_3:LED
                                        // P1_4:TXD0
                                        // P1_5:RXD0
        pd2 = 0xfe;                     // P2_0:スイッチ
                                        // P2_1:AIN1
                                        // P2_2:PWMA
                                        // P2_3:BIN1
                                        // P2_4:PWMB
                                        // P2_5:SERVO
                                        // P2_6:AIN2
                                        // P2_7:BIN2
        pd3 = 0xfb;                     // P3_2:赤外線受信
                                        // P3_4:ブザー
        pd4 = 0x80;                     // P4_2:VREF
                                        // P4_3〜P4_5:DIPSW
                                        // P4_6:XIN
                                        // P4_7:XOUT
        pd5 = 0x40;                     // P5_7:DIPSW
        pd6 = 0xff;                     // 



        mstcr = 0x00;                   // モジュールストップ解除



        // タイマRBの1ms割り込み設定
        trbmr = 0x00;                   // カウントソースはf1
        trbpre = 128 - 1;               // プリスケーラ
        trbpr = TIMER_CYCLE;            // プライマリカウンタ
        trbic = 0x01;                   // タイマRBの割り込みレベル設定
        trbcr = 0x01;                   // カウントを開始

        // タイマRCのPWMモード
        trccr1 = 0xb0;                  // カウントソースはf8
        trcgra = 0;                     // 圧電サウンダの周期
        trcgrc = 0;                     // 圧電サウンダのデューティ比
        trccr2 = 0x02;                  // TRCIOC端子はアクティブレベルH
        trcoer = 0x0b;                  // TRCIOC端子の出力許可
        trcpsr1 = 0x02;                 // TRCIOC端子をP3_4に割り当て
        trcmr = 0x8a;                   // カウントを開始

        // タイマRDのリセット同期PWMモード
        trdpsr0 = 0x08;                 // TRDIOB0端子をP2_2に割り当て
        trdpsr1 = 0x05;                 // TRDIOB1端子をP2_5に割り当て
                                        // TRDIOA1端子をP2_4に割り当て
        trdmr = 0xf0;                   // レジスタをバッファ動作にする
        trdfcr = 0x01;                  // リセット同期PWMモードに設定
        trdoer1 = 0xcd;                 // TRDIOB1の出力許可
                                        // TRDIOA1の出力許可
                                        // TRDIOB0端子の出力許可
        trdcr0 = 0x23;                  // カウントソースはf8
        trdgra0 = trdgrc0 = PWM_CYCLE;  // 周期
        trdgrb0 = trdgrd0 = 0;          // TRDIOB0端子（左モータ）
        trdgra1 = trdgrc1 = 0;          // TRDIOA1端子（右モータ）
        trdgrb1 = trdgrd1 = 0;          // TRDIOB1端子（サーボ）
        trdstr = 0x0d;                  // カウントを開始

        // 割り込み許可
        EI();
}

//------------------------------------------------------------------------------
// 割り込み
//------------------------------------------------------------------------------
#pragma interrupt intTRBIC (vect=24)
void intTRBIC( void )
{
        p0_7 = ~p0_7;

        if( p0_7 == 0 ){
                //p0_1、p0_3のモニタが可能
                p0_5 = ~p0_1;
                p0_6 = ~p0_3;
        }else{
                //p0_0、p0_2のモニタが可能
                p0_5 = p0_0;
                p0_6 = p0_2;
        }

        cnt0++;
        cnt1++;
}

//------------------------------------------------------------------------------
// センサー状態検出
// 引数         なし
// 戻り値       センサ値
//------------------------------------------------------------------------------
unsigned char sensor( void )
{
        volatile unsigned char  data1;

        data1 = ~p0;                    // ラインの色は白
        data1 = data1 & 0x0f;

        return( data1 );
}

//------------------------------------------------------------------------------
// モーター速度制御
// 引数         左モータ:-100〜100、右モータ:-100〜100
//              0で停止、100で正転100%、-100で逆転100%
// 戻り値       なし
//------------------------------------------------------------------------------
void motor( int data1, int data2 )
{
        volatile int    motor_r;
        volatile int    motor_l;
        volatile int    sw_data;

        sw_data = dipsw() + 5;
        motor_l = (long)data1 * sw_data / 20;
        motor_r = (long)data2 * sw_data / 20;

        if( motor_l >= 0 ) {
                p2_1 = 0;
                p2_6 = 1;
                trdgrd0 = (long)( PWM_CYCLE - 1 ) * motor_l / 100;
        } else {
                p2_1 = 1;
                p2_6 = 0;
                trdgrd0 = (long)( PWM_CYCLE - 1 ) * ( -motor_l ) / 100;
        }

        if( motor_r >= 0 ) {
                p2_3 = 0;
                p2_7 = 1;
                trdgrc1 = (long)( PWM_CYCLE - 1 ) * motor_r / 100;
        } else {
                p2_3 = 1;
                p2_7 = 0;
                trdgrc1 = (long)( PWM_CYCLE - 1 ) * ( -motor_r ) / 100;
        }
}

//------------------------------------------------------------------------------
// 時間稼ぎ
// 引数         タイマ値 1=1ms
// 戻り値       なし
//------------------------------------------------------------------------------
void timer( unsigned long data1 )
{
        cnt0 = 0;
        while( cnt0 < data1 );
}

//------------------------------------------------------------------------------
// 音を鳴らす
// 引数         (1/音の周波数)/(1/(クロック周波数/8))-1
// 戻り値       なし
//------------------------------------------------------------------------------
void beep( int data1 )
{
        trcgra = data1;                 // 周期の設定
        trcgrc = data1 / 2;             // デューティ50%のため周期の半分の値
}

//------------------------------------------------------------------------------
// DIPスイッチ状態検出
// 引数         なし
// 戻り値       0〜15、DIPスイッチがONの場合、対応するビットが0になります。
//------------------------------------------------------------------------------
unsigned char dipsw( void )
{
        volatile unsigned char  data1;

        data1 = ( ( p5 >> 4 ) & 0x08 ) | ( ( p4 >> 3 ) & 0x07 );

        return( data1 );
}

//------------------------------------------------------------------------------
// プッシュスイッチ状態検出
// 引数         なし
// 戻り値       スイッチが押されていない場合:0、押された場合:1
//------------------------------------------------------------------------------
unsigned char pushsw( void )
{
        unsigned char data1;

        data1 = ~p2;
        data1 &= 0x01;

        return( data1 );
}