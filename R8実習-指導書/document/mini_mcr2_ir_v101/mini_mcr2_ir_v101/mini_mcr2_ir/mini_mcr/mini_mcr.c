//------------------------------------------------------------------------------
// 対象マイコン R8C/35A
// ﾌｧｲﾙ内容     リモコンプログラム
// バージョン   Ver.1.00
// Date         2010.4.20
// Copyright    ルネサスマイコンカーラリー事務局
//              日立インターメディックス株式会社
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// インクルード
//------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include "sfr_r835a.h"
#include "printf_lib.h"

//------------------------------------------------------------------------------
// シンボル定義
//------------------------------------------------------------------------------
#define TIMER_CYCLE     155             // 1ms:0.001/(1/(20000000/128))-1
#define PWM_CYCLE       39999           // 16ms:0.016/(1/(20000000/8))-1

#define Def_500Hz       4999            // 500Hz:(1/500)/(1/(20000000/8))-1
#define Def_1000Hz      2499            // 1000Hz:(1/1000)/(1/(20000000/8))-1

#define Def_C3          19083           // ド:(1/131)/(1/(20000000/8))-1
#define Def_D3          17006           // レ:(1/147)/(1/(20000000/8))-1
#define Def_E3          15151           // ミ:(1/165)/(1/(20000000/8))-1
#define Def_F3          14285           // ファ:(1/175)/(1/(20000000/8))-1
#define Def_G3          12754           // ソ:(1/196)/(1/(20000000/8))-1
#define Def_A3          11362           // ラ:(1/220)/(1/(20000000/8))-1
#define Def_B3          10120           // シ:(1/247)/(1/(20000000/8))-1
#define Def_C4          9541            // ド:(1/262)/(1/(20000000/8))-1

#define DI()            asm("FCLR I")   // 割り込み禁止
#define EI()            asm("FSET I")   // 割り込み許可

#define DefIrS          11249           // リーダーコード(4.5ms):0.0045/(1/(20000000/8))-1
#define DefIrR          5624            // リピートリーダーコード(2.25ms):0.00225/(1/(20000000/8))-1
#define DefIr0          1412            // 0(0.565ms):0.000565/(1/(20000000/8))-1
#define DefIr1          4224            // 1(1.69ms):0.00169/(1/(20000000/8))-1
#define DefIrM          249             // マージン(0.1ms):0.0001/(1/(20000000/8))-1
//------------------------------------------------------------------------------
// 関数プロトタイプの宣言
//------------------------------------------------------------------------------
void init( void );
unsigned char sensor( void );
void motor( int data1, int data2 );
void timer( unsigned long timer_set );
void beep( int data1 );
unsigned char dipsw( void );
unsigned char pushsw( void );

//------------------------------------------------------------------------------
// グローバル変数の宣言
//------------------------------------------------------------------------------
unsigned long   cnt0 = 0;               // timer関数用
unsigned long   cnt1 = 0;               // main内で使用

volatile char   ir_data[64];
//------------------------------------------------------------------------------
// メインプログラム
//------------------------------------------------------------------------------
void main(void)
{
        int i;
        int button;

        // 初期化
        init();
        init_uart0_printf(SPEED_9600);

        while(1){

                // 赤外線の受信データのリーダーコード、リピートリーダーコードをクリア
                ir_data[0] = ' ';
                        
                // 受信のため待ち
                timer(200);

                // リーダーコード、リピートリーダーコードが受信されていなかった場合
                if( ir_data[0] == ' ' ){
                        // データをすべてクリア
                        for(i=0;i<60;i++){
                                ir_data[i] = ' ';
                        }
                }

                // ボタンが押されていない
                button = 0;
#if 1
//139 日立 地上アナログテレビ
                // 2ボタン
                if( strncmp( &ir_data[0], "S00001010111101010111000010001111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00001010111101010111000010001111", 1+32 ) == 0  ){
                        button = 2;
                }
                // 4ボタン
                if( strncmp( &ir_data[0], "S00001010111101010011100011000111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00001010111101010011100011000111", 1+32 ) == 0  ){
                        button = 4;
                }
                // 6ボタン
                if( strncmp( &ir_data[0], "S00001010111101010111100010000111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00001010111101010111100010000111", 1+32 ) == 0  ){
                        button = 6;
                }
                // 8ボタン
                if( strncmp( &ir_data[0], "S00001010111101010010000011011111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00001010111101010010000011011111", 1+32 ) == 0  ){
                        button = 8;
                }
#else
//134 NEC 地上アナログテレビ
                // 2ボタン
                if( strncmp( &ir_data[0], "S00011000111001111000100001110111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00011000111001111000100001110111", 1+32 ) == 0 ){
                        button = 2;
                }
                // 4ボタン
                if( strncmp( &ir_data[0], "S00011000111001111100100000110111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00011000111001111100100000110111", 1+32 ) == 0 ){
                        button = 4;
                }
                // 6ボタン
                if( strncmp( &ir_data[0], "S00011000111001111010100001010111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00011000111001111010100001010111", 1+32 ) == 0 ){
                        button = 6;
                }
                // 8ボタン
                if( strncmp( &ir_data[0], "S00011000111001111110100000010111", 1+32 ) == 0 ||
                        strncmp( &ir_data[0], "R00011000111001111110100000010111", 1+32 ) == 0 ){
                        button = 8;
                }
#endif

                switch( button ){
                // ボタンが押されていないか
                case 0:
                        motor( 0, 0 );  
                        break;

                // 2ボタンで前進
                case 2:
                        motor( 100, 100 );
                        break;

                // 4ボタンで左旋回
                case 4:
                        motor( 0, 100 );
                        break;

                // 6ボタンで右旋回
                case 6:
                        motor( 100, 0 );
                        break;

                // 8ボタンでバック
                case 8:
                        motor( -100, -100 );
                        break;

                default:
                        break;

                }

                // デバッグ出力
                for(i=0;i<60;i++){
                        printf("%c",ir_data[i]);
                }
                printf("\n");
                printf("\n");

        }

}

//------------------------------------------------------------------------------
// R8C/35Aの内蔵周辺機能の初期化
//------------------------------------------------------------------------------
void init( void )
{
        unsigned char i = 0;

        // 割り込み禁止
        DI();

        // クロック発生回路のXINクロック設定
        prc0 = 1;

        cm13 = 1;
        cm05 = 0;
        while(i <= 50) i++;
        ocd2 = 0;

        prc0 = 0;

        // I/Oポートの入出力設定
        prc2 = 1;                       // pd0レジスタへの書き込み許可
        pd0 = 0xe0;                     // P0_0〜P0_3:センサー
                                        // P0_4:マイクロスイッチ
                                        // P0_5〜P0_7:LED
        prc2 = 0;                       // pd0レジスタへの書き込み禁止
        pd1 = 0xdf;                     // P1_0〜P1_3:LED
                                        // P1_4:TXD0
                                        // P1_5:RXD0
        pd2 = 0xfe;                     // P2_0:スイッチ
                                        // P2_1:AIN1
                                        // P2_2:PWMA
                                        // P2_3:BIN1
                                        // P2_4:PWMB
                                        // P2_5:SERVO
                                        // P2_6:AIN2
                                        // P2_7:BIN2
        pd3 = 0xfb;                     // P3_2:赤外線受信
                                        // P3_4:ブザー
        pd4 = 0x80;                     // P4_2:VREF
                                        // P4_3〜P4_5:DIPSW
                                        // P4_6:XIN
                                        // P4_7:XOUT
        pd5 = 0x40;                     // P5_7:DIPSW
        pd6 = 0xff;                     // P6_7:\ENABLE\
                                        // P6_6:LATCH
                                        // P6_5:\SCLR\
                                        // P6_4:SCLK
                                        // P6_3:ROWA_SIN        行A
                                        // P6_2:ROWB_SIN        行B
                                        // P6_1:COL_SIN         列
                                        // P6_0:



        mstcr = 0x00;                   // モジュールストップ解除

        // タイマーRAのパルス幅測定モードで赤外線リモコンの受信パルスを測定
//      traioc = 0x00;                  // Lレベル幅、フィルタなし
//      traioc = 0x10;                  // Lレベル幅、フィルタあり
//      traioc = 0x01;                  // Hレベル幅、フィルタなし
        traioc = 0x11;                  // Hレベル幅、フィルタあり

        tramr = 0x13;                   // パルス幅測定モード f8
        trapre = 0xff;                  // 
        tra = 0xff;                     // 
        trasr = 0x03;                   // P3_2に割り当てる
        traic = 0x01;                   // タイマーRAの割り込みレベル設定
        tracr = 0x01;                   // スタート

        // タイマーRBの1ms割り込み設定
        trbmr = 0x00;                   // カウントソースはf1
        trbpre = 128 - 1;               // プリスケーラ
        trbpr = TIMER_CYCLE;            // プライマリカウンタ
        trbic = 0x01;                   // タイマーRBの割り込みレベル設定
        trbcr = 0x01;                   // カウントを開始

        // タイマーRCのPWMモード
        trccr1 = 0xb0;                  // カウントソースはf8
        trcgra = 0;                     // 圧電サウンダの周期
        trcgrc = 0;                     // 圧電サウンダのデューティ比
        trccr2 = 0x02;                  // TRCIOC端子はアクティブレベルH
        trcoer = 0x0b;                  // TRCIOC端子の出力許可
        trcpsr1 = 0x02;                 // TRCIOC端子をP3_4に割り当て
        trcmr = 0x8a;                   // カウントを開始

        // タイマーRDのリセット同期PWMモード
        trdpsr0 = 0x08;                 // TRDIOB0端子をP2_2に割り当て
        trdpsr1 = 0x05;                 // TRDIOB1端子をP2_5に割り当て
                                        // TRDIOA1端子をP2_4に割り当て
        trdmr = 0xf0;                   // レジスタをバッファ動作にする
        trdfcr = 0x01;                  // リセット同期PWMモードに設定
        trdoer1 = 0xcd;                 // TRDIOB1の出力許可
                                        // TRDIOA1の出力許可
                                        // TRDIOB0端子の出力許可
        trdcr0 = 0x23;                  // カウントソースはf8
        trdgra0 = trdgrc0 = PWM_CYCLE;  // 周期
        trdgrb0 = trdgrd0 = 0;          // TRDIOB0端子（左モーター）
        trdgra1 = trdgrc1 = 0;          // TRDIOA1端子（右モーター）
        trdgrb1 = trdgrd1 = 0;          // TRDIOB1端子（サーボ）
        trdstr = 0x0d;                  // カウントを開始

        // 割り込み許可
        EI();
}

//------------------------------------------------------------------------------
// 割り込み
//------------------------------------------------------------------------------

#pragma interrupt intTRAIC (vect=22)
void intTRAIC( void )
{
        static int      num = -1;
        unsigned short  data;
        int             i;

        // アンダーフロー
        if( tundf_tracr == 1){

                // アンダーフローフラグをクリア
                tundf_tracr = 0;

                tstart_tracr = 0;       // カウントストップ
                tra = 0xff;             // カウンタをリセット
                trapre = 0xff;          // カウンタをリセット
                tstart_tracr = 1;       // カウントスタート

        }

        // エッジ検出
        if( tedgf_tracr == 1){

                // エッジ検出フラグをクリア
                tedgf_tracr = 0;

                // カウンタ値を取得
                data = tra;
                data = data << 8;
                data = data + trapre;
                data = 65535 - data;

                // リーダーコード検出
                if( ( DefIrS - DefIrM ) < data && data < ( DefIrS + DefIrM ) ){
                        num = 0;
                        ir_data[0] = 'S';
                }
                
                // 0受信                
                if( ( DefIr0 - DefIrM ) < data && data < ( DefIr0 + DefIrM ) && 0 <= num && num <= 31 ){
                        num++;
                        ir_data[num] = '0';
                }

                // 1受信                
                if( ( DefIr1 - DefIrM ) < data && data < ( DefIr1 + DefIrM ) && 0 <= num && num <= 31 ){
                        num++;
                        ir_data[num] = '1';
                }

                // リピートリーダーコード検出
                if( ( DefIrR - DefIrM ) < data && data < ( DefIrR + DefIrM ) && num == 32 ){
                        ir_data[0] = 'R';
                }
                
                tstart_tracr = 0;       // カウントストップ
                tra = 0xff;             // カウンタをリセット
                trapre = 0xff;          // カウンタをリセット
                tstart_tracr = 1;       // カウントスタート
        
        }

}

#pragma interrupt intTRBIC (vect=24)
void intTRBIC( void )
{
        p0_7 = ~p0_7;

        if( p0_7 == 0 ){
                //p0_1、p0_3のモニタが可能
                p0_5 = ~p0_1;
                p0_6 = ~p0_3;
        }else{
                //p0_0、p0_2のモニタが可能
                p0_5 = p0_0;
                p0_6 = p0_2;
        }

        cnt0++;
        cnt1++;

}

//------------------------------------------------------------------------------
// センサー状態検出
// 引数         なし
// 戻り値       センサ値
//------------------------------------------------------------------------------
unsigned char sensor( void )
{
        volatile unsigned char  data1;

        data1 = ~p0;                    // ラインの色は白
        data1 = data1 & 0x0f;

        return( data1 );
}

//------------------------------------------------------------------------------
// モーター速度制御
// 引数         左モーター:-100〜100、右モーター:-100〜100
//              0で停止、100で正転100%、-100で逆転100%
// 戻り値       なし
//------------------------------------------------------------------------------
void motor( int data1, int data2 )
{
        volatile int    motor_r;
        volatile int    motor_l;
        volatile int    sw_data;

        sw_data = dipsw() + 5;
        motor_l = (long)data1 * sw_data / 20;
        motor_r = (long)data2 * sw_data / 20;

        if( motor_l >= 0 ) {
                p2_1 = 0;
                p2_6 = 1;
                trdgrd0 = (long)( PWM_CYCLE - 1 ) * motor_l / 100;
        } else {
                p2_1 = 1;
                p2_6 = 0;
                trdgrd0 = (long)( PWM_CYCLE - 1 ) * ( -motor_l ) / 100;
        }

        if( motor_r >= 0 ) {
                p2_3 = 0;
                p2_7 = 1;
                trdgrc1 = (long)( PWM_CYCLE - 1 ) * motor_r / 100;
        } else {
                p2_3 = 1;
                p2_7 = 0;
                trdgrc1 = (long)( PWM_CYCLE - 1 ) * ( -motor_r ) / 100;
        }
}

//------------------------------------------------------------------------------
// 時間稼ぎ
// 引数         タイマー値 1=1ms
// 戻り値       なし
//------------------------------------------------------------------------------
void timer( unsigned long data1 )
{
        cnt0 = 0;
        while( cnt0 < data1 );
}

//------------------------------------------------------------------------------
// 音を鳴らす
// 引数         (1/音の周波数)/(1/(クロック周波数/8))-1
// 戻り値       なし
//------------------------------------------------------------------------------
void beep( int data1 )
{
        trcgra = data1;                 // 周期の設定
        trcgrc = data1 / 2;             // デューティ50%のため周期の半分の値
}

//------------------------------------------------------------------------------
// DIPスイッチ状態検出
// 引数         なし
// 戻り値       0〜15、DIPスイッチがONの場合、対応するビットが0になります。
//------------------------------------------------------------------------------
unsigned char dipsw( void )
{
        volatile unsigned char  data1;

        data1 = ( ( p5 >> 4 ) & 0x08 ) | ( ( p4 >> 3 ) & 0x07 );

        return( data1 );
}

//------------------------------------------------------------------------------
// プッシュスイッチ状態検出
// 引数         なし
// 戻り値       スイッチが押されていない場合:0、押された場合:1
//------------------------------------------------------------------------------
unsigned char pushsw( void )
{
        unsigned char data1;

        data1 = ~p2;
        data1 &= 0x01;

        return( data1 );
}
